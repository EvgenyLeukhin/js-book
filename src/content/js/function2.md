# Functions

## Anonimus funcs by variables syntax

Функции в JS ведут себя как объекты. Можно вызывать функции через переменные. В такой записи в конце нужно ставить ; в конце.

```js
// WORK
const summing = function(a, b) {
  return (a + b);
};
summing;       // ошибки не будет (обращение REFERENCING)
summing(1, 2); // 3 вызов (CALL)

// ERROR
function(a, b) {
  return (a + b);
};
```

## Анонимная самовызывающаяся функция

Будет выполняться при загрузке. Чаще всего встречаются в замыканиях или в качестве аргумента другой функции.

```js
(function() {
  console.log('Something');
})();

// or
(() => console.log('Something!'))();

// with params
(function(text) {
  console.log(text);
})('Something');

// param of another function
setTimeout(
  function() { console.log('Test') },
  1000
);
```

## Methods of objects

Можно обращаться к анонимным функциям внутри объектов через свойства. ООП. Если функция является свойством объекта, то тогда она назыается методом.

```js
const car = {
  color: 'green',
  old: function(text) {
    console.log(text);
  },
  new(text) {
    console.log(text);
  },

  // this-keyword is a reference to current object
  showColor() {
    return `${this.color}`;
  }
};

car.open;             // ображение к методу (покажет тело функции)
car.old('Открыто!');  // вызов метода объекта car
car.new('Открыто!');  // вызов метода объекта car
```

## Scope

Каждая переменная i находится в своей области видимости, если во вложенной функции убрать объявление пременой, но вызов оставить, то в консоль выйдет значение i выше по коду. Local scope with let and const.

```js
const i = 1;
console.log(i); // 1

const func = () => {
  const i = 2;
  console.log(i); // 2

  const anotherFunc = () => {
    const i = 3;
    console.log(i); // 3
  }
}
```

## Замакания

Если внутри функции объявить ещё одну функцию, то эта вложенная функция будет "видеть" все переменные родительской функции. Переменные видят друг друга на одном уровне

Короче замыкания, это функция объявленная внутри функции, благодаря которой локальные переменные внутри старшей функции не сбрасываются после завершения работы этой функции, а остаются при повторном вызове. Замыканиями они называются потому, что младшая функция их замыкает внутри старшей. А почему так происходит, х.з. видимо фича языка.

То есть с помощью замыканий можно обращаться к значениям переменной какой-либо замкнутой функции внутри другой функции, в которой имеется точно такая же переменная. При этом значение переменной будет как в ЗАМКНУТОЙ функции, а не как в родительской

```js
const func1 = () => {
  const i = 10;
  return () => i;
};

func1()(); // 10

const func2 = () => {
  const i = 20;
  console.log(`i from parent func: ${i}`); // 20
  console.log(`i from anoter external closed func: ${func1()()}`); // 10
};

func2();
```

### By steps

```js
// сохраняем функцию в переменную
var func1 = function() {
  // объявляем внутри неё переменную i
  var i = 10;
  // внутри этой функции возвращаем анонимную функцию, которая возвращает значение переменной i, эта
  // функция и будет ЗАМЫКАТЬ переменную i
  return function() { return i; }
}

// проверим, создав другую функцию с такой же переменной, но с другим значением
var func2 = function() {
  var i = 20;
  console.log(i);         // 20
  // эти два выражения находятся на одном уровне, но при вызове замыкающей функции перевой функции, она
  // будет нам возвращать другое значение одноимённой переменной, это и есть ЗАМЫКАНИЕ, которое нарушает
  // стандартное поведение SCOPE
  console.log(func1()()); // 10
}
func2();
```

## This

Это что-то вроде переменной, которая автоматически создается у объектов и функций, ограничивается {}, разные this друг о друге ничего не знают.

## Call-back function

Простыми словами, это вызов какой-либо функции (колбэк-функции) по окончанию работы какой-либо основной функции. Эти функциии каким-то образом связаны, колбек должен знать, когда выполниться основная, чтобы выполниться самой. Колбэк будет ждать пока выполниться код основной феункции, а потом выполниться сам.
Применяется в запросах на серверы(old school).

Пример колбэка в синхронной функции. Код выполниться сразу.

```js
function doHomework(subject, callback) {
  alert(`Starting my ${subject} homework.`);
  callback();
}

doHomework('math', function() {
  alert('Finished my homework');
});
```

## Recurtion function
